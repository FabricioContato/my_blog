<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Building a Comment Section with Free Tools</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism.css" rel="stylesheet" />
  
  <link rel="stylesheet" href="./css_js/style.css" type="text/css" media="all">
</head>
<body style="background-color: hsl(35, 30%, 96%)">
  <div class="container" style="background-color: white">
    <nav class="navbar navbar-expand-lg navbar-dark" style="background-color: #2b4b7a;">
      <div class="container-fluid">
        <a class="navbar-brand" href="/">
        <span>&#60;<i class="bi bi-house-door-fill"></i>&#62;</span>
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
          aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav ">
            <li class="nav-item">
              <a class="nav-link text-white font-weight-bold" href="/about.html">&#60;About&#62;</a>
            </li>
          </ul>
        </div>
      </div>
    </nav> <div class="card card-body mb-3">  <h1>Construindo uma Seção de Comentários com Ferramentas Gratuitas  </h1>  <p class="my-2">Acredito que existam soluções prontas para uma seção de comentários, mas esse não é o espírito deste blog. Quero construir minha própria solução.  </p>  <p class="my-2">Minha primeira ideia foi implementar com um banco de dados e uma API hospedada em algum serviço de nuvem, mas fiquei com medo de gastar dinheiro. Este blog não gera receita e não tenho tráfego suficiente para justificar investimentos. Portanto, meu objetivo se tornou implementar usando recursos gratuitos.  </p>  <p class="my-2">Acabei escolhendo Google Planilhas, Google Apps Script e EmailJS:  </p>  <ul>   <li>    <strong>Google Planilhas    </strong>    é o equivalente do Google ao Excel que estou usando como banco de dados.    
   </li>   <li>    <strong>Google Apps Script    </strong>    é uma plataforma de script que pode ser usada como API.    
   </li>   <li>    <strong>EmailJS    </strong>    é um serviço que permite enviar e-mails para você mesmo a partir do código JavaScript.    
   </li>  </ul>  <p class="my-2">Você deve estar pensando: "Por que precisa do EmailJS?" Uma ferramenta de e-mail não faz parte de uma típica web-stack, e eu também não queria adicioná-la.  </p>  <p class="my-2">O problema é que, ao trabalhar com ferramentas gratuitas, você pode enfrentar limitações estranhas que exigem soluções igualmente estranhas. Vou explicar mais a baixo.  </p>  <small>24 de abril de 2025  </small> </div> <div class="card card-body mb-3">  <h2>Google Planilhas e Google Apps Script  </h2>  <p class="my-2">Google Planilhas é basicamente o equivalente do Google ao Excel - uma aplicação de planilha para necessidades diárias ou empresariais. Para cada Planilha Google, você pode ter um Google Apps Script escrito em JavaScript para automação. Ambas as ferramentas têm opções gratuitas.  </p>  <p class="my-2">O principal aqui é que o Google Apps Script pode ser implantado como um aplicativo web, capaz de servir arquivos e dados, e tem conexão fácil com o Google Planilhas. Para este projeto, só me importo com os dados, então o Apps Script funciona como uma API para mim.  </p> </div> <div class="card card-body mb-3">  <h2>Escolhendo Google Apps Script  </h2>  <p class="my-2">Existem outros serviços gratuitos que permitem a implementação de APIs e bancos de dados, então por que Google Apps Script?  </p>  <p class="my-2">Bem, admito que não pesquisei o suficiente no início e acabei com algo que sabia ser gratuito e simples. Agora que já gastei um bom tempo fazendo funcionar, vai ficar assim por enquanto.  </p>  <p class="my-2">Ainda assim, vejo algumas vantagens. Estou lidando com o Google, um provedor conhecido em que posso confiar, e o Google Planilhas é um "banco de dados" tão simples de editar que poderia configurar um projeto web para alguém com pouca experiência técnica, e essa pessoa ainda conseguiria gerenciar os dados. Desde que tenha uma conta do Google, provavelmente se sentirá familiarizada com a ferramenta. Portanto, aprender sobre essas ferramentas pode ser útil para alguns clientes freelancers.  </p> </div> <div class="card card-body mb-3">  <h2>Usando doGet(e) e doPost(e)  </h2>  <p class="my-2">Google Apps Script usa doGet e doPost como endpoints para os métodos HTTP GET e POST. Não é tão flexível quanto web frameworks disponíveis para Node.js, que permitem criar quantos endpoints você quiser, mas é suficiente para minhas necessidades atuais.  </p>  <p class="my-2">No entanto, há um problema: Apps Script foi feito principalmente para o ecossistema Google, e há algumas limitações ao lidar com outros domínios.  </p>  <p class="my-2">Por exemplo, não consegui fazer meu site acessar o endpoint doPost - as configurações de CORS (Cross-Origin Resource Sharing) no meu navegador não permitiam a comunicação com doPost. Para resolver isso, precisaria definir o cabeçalho de resposta do doPost, mas o Google não permite isso por motivos de segurança.  </p>  <p class="my-2">Minha solução foi usar um serviço de e-mail como minha requisição POST... embaraçoso, eu sei.  </p> </div> <div class="card card-body mb-3">  <h2>EmailJS  </h2>  <p class="my-2">EmailJS é um serviço que permite enviar e-mails do seu front-end JavaScript para sua caixa de entrada. Navegadores não permitem enviar e-mails diretamente do front-end JavaScript por motivos de segurança, então o EmailJS age como intermediário. Seu formulário HTML envia uma mensagem para os servidores do EmailJS, que então encaminham a mensagem como um e-mail para sua caixa de entrada.  </p>  <p class="my-2">Uma vez que o e-mail chega, sua mensagem pode ser trazida para a planilha por automação escrita no código do Google Apps Script.  </p>  <p class="my-2">Mas agora enfrentamos outro problema: Apps Script não aciona ações baseadas na chegada de e-mails. Eu poderia definir um temporizador para um script verificar minha caixa de entrada periodicamente, mas essa solução parece pouco otimizada - um intervalo curto faria o Apps Script trabalhar em vão muitas vezes. Um intervalo longo faria os usuários não verem resultado imediato após enviar um comentário, fazendo-os pensar que a seção de comentários não funciona.  </p>  <p class="my-2">Minha solução foi verificar a caixa de entrada toda vez que uma requisição GET é feita. Na função doGet, o código primeiro verifica novos e-mails com o assunto "blog_comment", atualiza a planilha de comentários, copia a planilha, transforma em um arquivo JSON e então envia de volta como resposta.  </p>  <p class="my-2">Essa abordagem torna o carregamento de comentários mais lento, mas está bom por enquanto.  </p> </div> <div class="card card-body mb-3">  <h2>Meu código no App Script por enquanto  </h2>  <pre class="language-javascript"><code> function doGet(e) {   
   // verifica novos e-mails de comentários para adicionar à planilha de comentários   
   const sheet = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();   
   const threads = GmailApp.search('subject:blog_comment is:unread');   
   
   // atualizar a planilha de comentários   
   threads.forEach(thread =&gt; {   
     const messages = thread.getMessages();   
     messages.forEach(msg =&gt; {   
     const name = msg.getFrom().split(' &lt;')[0];   
     // Uso ##end## para separar partes do corpo do e-mail   
     // Você não precisa escrever (##end##) no comentário. É colocado lá por padrão   
     const [postId, message] = msg.getPlainBody().split("###end###");   
    
     sheet.appendRow([postId, name, message]);   
     });   
     thread.markRead();    
   });   
    
   //retornando os dados como json   
   const data = sheet.getDataRange().getValues();   
   const postId = e.parameter['post_id'];   
   const filtered_data = data.filter(row =&gt; String(row[0]) === String(postId));   
    
    
   var jsonData = [];   
   for (var i = 0; i &lt; filtered_data.length; i++) {   
     jsonData.push({   
     PostId: filtered_data[i][0],   
     Name: filtered_data[i][1],   
     Message: filtered_data[i][2]   
     });   
   };   
    
   return ContentService.createTextOutput(JSON.stringify(jsonData))   
     .setMimeType(ContentService.MimeType.JSON);   
    
 }   
  </code></pre> </div> <div class="card card-body mb-3">  <h2>Política de Segurança de Conteúdo (CSP) do Neocities  </h2>  <p class="my-2">Agora, com meu backend configurado, era hora de fazer alguns testes de requisição. Eles falharam... Aparentemente, o Neocities - meu host na época - tinha configurações CSP que proibiam buscar recursos de outros domínios. Só era permitido buscar do domínio do Neocities.  </p>  <p class="my-2">Como o Neocities não permite acesso ou edição do CSP, me vi forçado a buscar outro host. Agora estou usando Cloudflare. Aqui, posso definir meu próprio CSP, e também é uma opção de hospedagem gratuita. Não é uma comunidade como o Neocities, mas eu não estava contando muito com isso mesmo.  </p>  <p class="my-2">No Cloudflare, posso conectar meu host ao repositório GitHub do meu blog, então quando atualizo a branch master, automaticamente "subo" a nova versão do blog para produção. Legal! Talvez um dia eu tenha um pipeline mais complexo para escrever sobre.  </p>  <p class="my-2">Agora, meus testes de requisição são bem-sucedidos.  </p> </div> <div class="card card-body mb-3">  <h2>Front-end Dinâmico  </h2>  <p class="my-2">Talvez esse assunto traga à mente frameworks como ReactJS, mas essa não é minha tarefa hoje. Meu objetivo era simplesmente receber um JSON do backend com os dados dos comentários e, para cada comentário, exibir um card Bootstrap mostrando o nome do usuário e a mensagem. Implementei isso com JavaScript puro, HTML e Bootstrap (CSS).  </p> </div> <div class="card card-body mb-3">  <h2>Meu código FrontEnd JS para buscar e exibir comentários  </h2>  <pre class="language-javascript"><code>async function fetchData() {   
  // Buscando dados dos comentários   
  const parameters = `?post_id=${document.getElementById("post_id").value}`;   
  const response = await fetch(`https://script.google.com/macros/s/AKfycbzN3qxsiTKoi2sVrRE6QzhTWWp4qYEGzsBpiDtz7U0cfjbkEpP-w16S_r3rL_Fbzl3Q/exec${parameters}`);   
  const data = await response.json();   
   
  // Escondendo a mensagem 'Carregando comentários...'   
  document.getElementById("loading_comments").classList.add("d-none");   
   
  const comment_section = document.getElementById('comments');   
     
  // Criando cards para cada dado de comentário   
  data.reverse().forEach(row =&gt; {   
      comment_section.appendChild(createCard(row.Name, row.Message));   
  });   
}   
   
// Executando função ao carregar a página   
window.onload = fetchData;   
   
  </code></pre>  <h2>Função auxiliar que constrói cards de comentário  </h2>  <pre class="language-javascript"><code>   
function createCard(name, message){   
  const div = document.createElement("div");   
  const div_flex = document.createElement("div");   
  const h3 = document.createElement('h3');   
  const p = document.createElement('p');   
  const icon = document.createElement('i');   
   
  div.classList.add("card","card-body","my-1");   
  div_flex.classList.add("d-flex");   
  icon.classList.add("bi","bi-person-circle", "d-inline");   
  h3.textContent = `${name}`;   
  h3.classList.add("d-inline","mx-2");   
  p.textContent = `${message}`;   
   
   
  div_flex.appendChild(icon);   
  div_flex.appendChild(h3);   
  div.appendChild(div_flex);   
  div.appendChild(p);   
   
  return div;   
}   
  </code></pre> </div> <div class="card card-body mb-3">  <h2>Segurança  </h2>  <p class="my-2">Agora meu sistema de blog tem um ponto de entrada para intenções maliciosas, e não posso simplesmente ignorar isso.  </p>  <p class="my-2">Há medidas importantes que preciso implementar, como:  </p>  <ul>   <li>Validação   </li>   <li>Sanitização   </li>   <li>Moderação   </li>  </ul>  <p class="my-2">Pode haver mais, mas esse é um tópico para outro post.  </p> </div> <form class="card card-body mb-3" id="comment-form">
      <h6 class="mb-3 text-muted">Leave a comment</h6>
      <div class="mb-2">
        <input type="text" name="name" class="form-control form-control-sm border-0 border-bottom rounded-0 bg-transparent" id="name" placeholder="Name" required="">
      </div>
      <div class="mb-2">
        <textarea name="message" class="form-control form-control-sm border-0 border-bottom rounded-0 bg-transparent" id="comment" rows="3" placeholder="Your comment..." required=""></textarea>
      </div>
      <input type="hidden" name="post_id" id="post_id" value="2 ">
      <div class="text-end">
        <button type="submit" class="btn btn-sm btn-outline-secondary">Post</button>
      </div>
    </form>
    <span id="loading_comments" class="d-block">Loading comments...</span>
    <span id="sending_comment" class="d-none">Sending your comment...</span>
    <span id="fetching_erro" class="d-none">&#128533; Something went wrong while fetching comments.</span>
    <span id="sending_erro" class="d-none">&#128533; Something went wrong while sending your comment, try again later.</span>
    <span id="invalidComment" class="d-none">&#128679; Your comment or name has fobiden characters ( < > " ' / \ = ( ) { } [ ] ; : @ & + % # $ ` )</span>
    <div id="comments"></div>

  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
  <script type="text/javascript" src="css_js/script.js"></script>
</body>
</html>